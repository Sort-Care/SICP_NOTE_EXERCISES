#+STARTUP: nolatexpreview
* Chapter 2 Exercises
** 2.1
Define a better version of ~make-rat~ that handles both positive and negative arguments. ~Make-rat~ should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.
#+begin_src scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (make-rat n d)
    (cond ((and (> n 0) (> d 0)) (make-rat-with-sign 1 n d (gcd n d)))
          ((and (< n 0) (< d 0)) (make-rat-with-sign 1 (abs n) (abs d) (abs (gcd n d))))
          ((and (< n 0) (> d 0)) (make-rat-with-sign -1 (abs n) d (abs (gcd n d))))
          (else (make-rat-with-sign -1 n (abs d) (abs (gcd n d))))))

  (define (make-rat-with-sign sign n d g)
    "We assume that n, d, g are all positive."
    (if (= sign 1)
        (cons (/ n g) (/ d g))
        (cons (/ (- n) g) (/ d g))))
#+end_src
** 2.2
Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~ that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the $x$ coordinate and the $y$ coordinate. Accordingly, specify a constructor ~make-point~ and selectors ~x-point~ and ~y-point~ that define this representation. Finally, using your selectors and constructors, define a procedure ~midpoint-segment~ that takes a line segment as arguments and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you'll need a way to print points:
#+begin_src scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display (","))
    (display (y-point p))
    (display ")"))
#+end_src

#+begin_src scheme
  (define (midpoint-segment s)
    (let ((a (start-segment s))
          (b (end-segment s)))
      (make-point (/ (+ (x-point a)
                        (x-point b))
                     2.0)
                  (/ (+ (y-point a)
                        (y-point b))
                     2.0))))

  ;;--------- SEGMENT
  (define (make-segment p1 p2)
    (cons p1 p2))

  (define (start-segment s)
    (car s))

  (define (end-segment s)
    (cdr s))

  ;;--------- POINTS
  (define (make-point x y)
    (cons x y))

  (define (x-point p)
    (car p))

  (define (y-point p)
    (cdr p))
#+end_src
** 2.3
Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2). In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

#+begin_src scheme
  ;; ----------- PERIMETER and AREA of RECTANGLE
  (define (rect-perimeter rect)
    (+ (* (a-rect rect) 2)
       (* (b-rect rect) 2)))

  (define (rect-area rect)
    (* (a-rect rect) (b-rect rect)))

  ;; ----------- RECTANGLE REPRESENTATION 1
  ;; constructor
  ;; selector
  (define (make-rect seg1 seg2)
    (cons seg1 seg2))

  (define (a-rect rect)
    "Returns the length of one edge of rectangle."
    (seg-length (car rect)))

  (define (b-rect rect)
    "Returns the length of an adjacent edge of what a-rect returns."
    (seg-length (cdr rect)))


  ;; -----------
  (define (seg-length seg)
    (let ((a (start-segment seg))
          (b (end-segment seg)))
      (sqrt (+ (square (- (x-point a) (x-point b)))
                (square (- (y-point a) (y-point b)))))))
#+end_src

Then, try a different representation:
#+begin_src scheme
  (define (make-rect seg1 seg2)
    "Putting properties along with the segments."
    (cons (cons seg1 seg2)
          (cons (seg-length seg1) (seg-length seg2))))

  ;; because the calculation was done in the constructor,
  ;; we can make fetching them in following procedures faster
  ;; suitable for a application where the following are called
  ;; frequently.
  (define (a-rect rect)
    (car (cdr rect)))

  (define (b-rect rect)
    (cdr (cdr rect)))
#+end_src

** 2.4
Here is an alternative procedural representation of pairs. For this representation, verify that ~(car (cons x y))~ yields ~x~ for any objects ~x~ and ~y~.
#+begin_src scheme
  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))
#+end_src

What is the corresponding definition of ~cdr~? (Hint: To verify that this works make use of the substitution model of section 1.1.5)

#+begin_src scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+end_src

Then running ~(car (cons x y))~:
#+begin_src scheme
(car (cons x y))
(car (lambda (m) (m x y)))
((lambda (m) (m x y)) (lambda (p q) p))
((lambda (p q) p) x y)
x
#+end_src

My question: What will happen if we nest some pairs? Then try to select some inner elements.
#+begin_src scheme
  (define A (cons x y))
  (define B (cons A z))
  ;; then run
  (car (car B))

  ;;
  (car (car (cons A z)))
  (car (car (cons (cons x y) z)))
  (car (car (cons (lambda (m) (m x y)) z)))
  (car (car (lambda (m) (m (lambda (m) (m x y)) z))))
  (car ((lambda (m) (m (lambda (m) (m x y)) z)) (lambda (p q) p)))
  (car ((lambda (p q) p) (lambda (m) (m x y)) z))
  (car (lambda (m) (m x y)))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x
#+end_src
** 2.5
Show that we can represent pairs of non-negative integers using only numbers and arithmetic operations if we represent the pair $a$ and $b$ as the integer that is the product $2^a3^b$. Give the corresponding definitions of the procedures ~cons~, ~car~ and ~cdr~.

#+begin_src scheme
  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b
                   (fast-expt b (- n 1))))))

  (define (even? x)
    (= (remainder x 2) 0))

  (define (my-cons x y)
    (* (fast-expt 2 x)
       (fast-expt 3 y)))

  ;; how to get the x and y here easily?
  ;; The apparent solution is to utilize an iterative approach and divide the number.
  ;; But the running time of that approach is linear.
  ;; Is there an constant time solution?
  (define (my-car z)
    (how-many z 2))

  (define (my-cdr z)
    (how-many z 3))

  (define (how-many num div)
    (define (try-divide n res)
      (if (= (remainder n div) 0) ;; still can be divided by the div
          (try-divide (/ n div) (+ res 1)) ;; continue with new number and add 1 to the result
          res))
    (try-divide num 0))
#+end_src
** 2.6
In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as non-negative integers are concerned) by implementing 0 and the operation of adding 1 as:

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src
This representation is known as /Church numerals/, after its inventor, Alonzo Church, the logician who invented the $\lambda$ calculus.

Define ~one~ and ~two~ directly (not in terms of ~zero~ and ~add-1~). (Hint: Use substitution to evaluate ~(add-1 zero)~). Given a direct definition of the addition procedure ~+~ (not in terms of repeated application of ~add-1~).

First, let's try evaluate ~(add-1 zero)~:
#+begin_src scheme
  (add-1 zero)
  (add-1 (lambda (f)
           (lambda (x) x)))

  (lambda (f)
    (lambda (x)
      (f (((lambda (f)
             (lambda (x) x))
           f)
          x))))


  (lambda (f)
    (lambda (x)
      (f ((lambda (x) x)
          x))))

  (lambda (f)
    (lambda (x)
      (f x)))
  ;; ????
#+end_src

*** What is Church Numerals?
I really had difficulties in understanding this. So I resort to the wikipedia page, not for the exact answer, but for some insights.

And the following sentence at the very beginning of the article was very helpful:
#+begin_quote
Church numerals are the representations of natural numbers under Church encoding. The higher-order function that represents natural number $n$ is a function that maps any function $f$ to its n-fold composition. In simpler terms, the "value" of the numeral is equivalent to the number of times the function encapsulates its argument.

All Church numerals are functions that take two parameters.
#+end_quote

$$
f^{\circ n} = f \circ f \circ f \circ \cdots \circ f
$$

And to do the ~+~ procedure:

$$
plus(m, n) = m + n
$$

uses the identity
$$
f^{\circ (m+n)} (x) = f^{\circ m} ( f^{\circ n} (x))
$$

*** Then, Implement ~one~, ~two~, and ~+~ Procedure
#+begin_src scheme
  (define one
    (lambda (f) (lambda (x) (f x))))

  (define two
    (lambda (f) (lambda (x) (f (f x)))))

  (define +
    (lambda (f) (lambda (x) ((m f) ((n f) x)))))
#+end_src

To improve our understanding here, I decided to do more. Next I will try the ~mult~ procedure:

$$
f^{\circ (m\cdot n)}(x) = (f^{\circ n})^{\circ m} (x)
$$

which means apply function $f^{\cric n}$, $m$ times to $x$.

#+begin_src scheme
  (define (mul m n)
    (lambda (f) (lambda (x) ((m
                              (n f))
                             x))))
#+end_src

That is not so hard to understand. But next function: /predecessor/, is really hard to wrap your mind around it.
The predecessor function must return a function that applies its parameter $n-1$ times. This is achieved by building a container around $f$ and $x$, which is initialized in a way that omits the application of the function the first time.
#+begin_src scheme
;; TODO predecessor and minus procedure for Church Numerals
#+end_src
** 2.7
Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor
#+begin_src scheme
  (define (make-interval a b) (cons a b))
#+end_src
Define selectors ~upper-bound~ and ~lower-bound~ to complete the implementation.
#+begin_src scheme
  (define (lower-bound x) (car x))
  (define (upper-bound x) (cdr x))
#+end_src
** 2.8
Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called ~sub-interval~.

Because ~(sub-interval x y)~ is using some number within interval ~x~ and subtract it with some number within interval ~y~.
Thus the lower bound of the resulting interval is subtracting the upper bound of ~y~ from the lower bound of ~x~.
And the upper bound of the resulting interval is subtraction the lower bound of ~y~ from the upper bound of ~x~.
#+begin_src scheme
  (define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))
#+end_src
** 2.9
The /width/ of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the width of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the width of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.

Let's assume that $I_1$ and $I_2$ are two intervals we are going to apply arithmetic operations to. $I_3$ is the resulting interval.
Also, say $L_i$ and $U_i$ are the lower bound and upper bound of a interval $i$ respectively. $W_i$ is the width of interval $i$.

Then when the operation is sum:
$$
\begin{align*}
W_1 &= \frac{U_1 - L_1}{2} \\
W_2 &= \frac{U_2 - L_2}{2} \\
I_3 &= (L_1 + L_2, U_1 + U2) \\
W_3 &= \frac{(U_1 + U_2) - (L_1 + L_2)}{2} \\
&= \frac{(U_1 - L_1) + (U_2 - L_2)}{2} \\
&= W_1 + W_2
\end{align*}
$$

Similarly for difference:
$$
\begin{align*}
I_4 &= (L_1 - U_2, U_1 - L_2) \\
W_4 &= \frac{(U_1 - L_2) - (L_1 - U_2)}{2} \\
&= \frac{(U_1 - L_1) + (U_2 - L_2)}{2} \\
&= W_1 + W_2
\end{align*}
$$

And for multiplication, the obvious reason is that it is not a linear transformation of all bounds (~max~ and ~min~ are not linear transform operations). For example, if we have $(-1, 9)$ and $(3, 7)$, after multiplication, we get $(-7, 63)$. Number 3 did not even participated in forming the multiplication result.

Further more, even if there is no negative numbers involved, which means all transformations are linear:

$$
\begin{align*}
I_5 &= (L_1L_2, U_1U_2) \\
W_5 &= \frac{U_1U_2 - L_1L_2}{2}
\end{align*}
$$

We cannot represent $W_5$ in terms of $W_1$ and $W_2$ merely.
** 2.10
Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divided by an interval that spans ~zero~. Modify Alyssa's code to check for this condition and to signal an error if it occurs.
#+begin_src scheme
  (define (div-interval x y)
    (if (<= (* (lower-bound y) (upper-bound y)) 0)
        (error "Divided by an interval that spans zero.")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
#+end_src
** 2.11
In passing, Ben also cryptically comments: "By testing the signs of the endpoints of the intervals, it is possible to break ~mul-interval~ into nine cases, only one of which requires more than two multiplications." Rewrite this procedure using Ben's suggestion.
#+begin_src scheme
  (define (mul-interval x y)
    (let ((l1 (lower-bound x))
          (u1 (upper-bound x))
          (l2 (lower-bound y))
          (u2 (upper-bound y)))
      (cond ((and (>= l1 0) (>= l2 0)) ;; both intervals are non-negative
             (make-interval (* l1 l2)
                            (* u1 u2)))
            ((and (< l1 0) (>= u1 0) (>= l2 0)) ;; x span zero, y above zero
             (make-interval (* l1 u2)
                            (* u1 u2)))
            ((and (< u1 0) (>= l2 0)) ;; x below zero, y above zero
             (make-interval (* l1 u2)
                            (* u1 l2)))
            ((and (>= l1 0) (< l2 0) (>= u2 0)) ;; x above zero, y span zero
             (make-interval (* l2 u1)
                            (* u1 u2)))
            ((and (< l1 0) (>= u1 0) (< l2 0) (>= u2 0)) ;; x span zero, y span zero
             (make-interval (min (* l1 u2) (* l2 u1))
                            (max (* l1 l2) (* u1 u2))))
            ((and (< u1 0) (< l2 0) (>= u2 0)) ;; x below zero, y span zero
             (make-interval (* l1 u2)
                            (* l1 l2)))
            ((and (>= l1 0) (< u2 0)) ;; x above zero, y below zero
             (make-interval (* l2 u1)
                            (* u2 l1)))
            ((and (< l1 0) (>= u1 0) (< u2 0)) ;; x span zero, y below zero
             (make-interval (* l2 u1)
                            (* l2 l1)))
            ((and (< u1 0) (< u2 0)) ;; x below zero, y below zero
             (make-interval (* l1 l2)
                            (* u1 u2))))))
#+end_src
** 2.12
Define a constructor ~make-center-percent~ that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector ~percent~ that produces the percentage tolerance for a given interval. The ~center~ selector is the same as the one shown above.
#+begin_src scheme
  (define (make-center-percent c p)
    (let ((t (* c p)))
      (make-interval (- c t)
                     (+ c t))))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (percent i)
    (let ((c (center i)))
      (/ (- c (lower-bound i))
         c)))
#+end_src
** 2.13
Show that under the assumption of small percentage tolerance there is a simple formula for the approximate percentage tolerance of the product of two interval in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.

Let $c_i$, $p_i$, $l_i$, $u_i$ be the center, percentage, lower bound, upper bound of interval $i$. Say $I_3$ is the result of multiplying $I_1$ and $I_2$.

$$
\begin{align*}
l_1 &= c_1 - c_1 p_1 \\
l_2 &= c_2 - c_2 p_2 \\
l_3 &= c_1 c_2 (1 - p_1) (1 - p_2) \\
u_3 &= c_1 c_2 (1 + p_1) (1 + p_2) \\
c_3 &= \frac{c_1 c_2 ((1 - p_1) (1 - p_2) + (1 + p_1) (1 + p_2))}{2} \\
p_3 &= \frac{c_3 - l_3}{c_3} \\
    &= \frac{ \frac{c_1 c_2 ( (1 + p_1) (1 + p_2) - (1 - p_1) (1 - p_2))}{2} }{c_3} \\
    &= \frac{(1 + p_1) (1 + p_2) - (1 - p_1) (1 - p_2)}{(1 + p_1) (1 + p_2) + (1 - p_1) (1 - p_2)} \\
    &= \frac{p_1 + p_2}{1 + p_1 p_2}
\end{align*}
$$
** 2.14
Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals $A$ and $B$, and use them in computing the expressions $A/A$ and $A/B$. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).

#+begin_src scheme
  (define (print-interval i)
    (newline)
    (display "Lower Bound: ")
    (display (lower-bound i))
    (newline)
    (display "Upper Bound: ")
    (display (upper-bound i))
    (newline)
    (display "Center: ")
    (display (center i))
    (newline)
    (display "Tolerance Percent: ")
    (display (percent i)))
#+end_src

Ran it with:

#+begin_src scheme
  (define a (make-center-percent 50 0.0001))
  (define b (make-center-percent 63 0.0001))

  (print-interval (par1 a b))

  (print-interval (par2 a b))
#+end_src

Seems like the ~par1~ is giving the wrong answer here. The center is relatively accurate, but the lower bound and upper bound are not. And that leads to the percentage of tolerance of the result is not correct. But why does this happen?
#+begin_src bash
=> (print-interval (par1 a b))

Lower Bound: 27.867744477764607
Upper Bound: 27.88447014170444
Center: 27.876107309734522
Tolerance Percent: 2.9999999200013147e-4
;Unspecified return value

=> (print-interval (par2 a b))

Lower Bound: 27.87331858407079
Upper Bound: 27.878893805309733
Center: 27.876106194690262
Tolerance Percent: 1.0000000000007373e-4
;Unspecified return value
#+end_src

I get the most insight for this problem, in contrast to what the text said, from using intervals with large width.

It turned out that ~par1~ and ~par2~ are not computing the same thing at all when $R_1$ and $R_2$ are intervals. To see why, let's see what the procedure is really doing by explicitly writing out the calculations.

Let $A = (L_1, U_1)$, $B = (L_2, U_2)$.

For ~par1~:
$$
\begin{align*}
(mul \; a \; b) &= (L_1 L_2, U_1 U_2) \\
(add \; a \; b) &= (L_1 + L_2, U_1 + U_2) \\
\text{then perform division} &\\
\frac{(mul \; a \; b)}{(add \; a \; b)} &= (\frac{L_1 L_2}{U_1 + U_2}, \frac{U_1 U_2}{L_1 + L_2} )
\end{align*}
$$

While for ~par2~:

$$
\begin{align*}
(div \; one \; a) &= (\frac{1}{U_1}, \frac{1}{L_1}) \\
(div \; one \; b) &= (\frac{1}{U_2}, \frac{1}{L_1}) \\
\text{then add them together} &\\
sum &= (\frac{U_1 + U_2}{U_1 U_2}, \frac{L_1 + L_2}{L_1 L_2}) \\
\text{finally, divide one by the sum} &\\
(div \; one \; sum) &= (\frac{L_1 L_2}{L_1 + L_2}, \frac{U_1 U_2}{U_1 + U_2})
\end{align*}
$$

The problem is, although the two formulas are equivalent in pure algebra sense, they are not under the interval arithmetic. It lacks the property of $\frac{A}{B} \cdot B = A$. In the current interval arithmetic system, $\frac{A}{B} \cdot B \neq A$ in most cases (any case that the lower bound and upper bound of $B$ are not the same). And that, is what caused the inconsistency between two ways of computing the parallel resistor value.

More generally, the problem is, $A \cdot \frac{1}{A} \neq (1, 1)$. To put it in words, the product of an interval and its inverse ($(1, 1)$ divided by the interval) is not $(1,1)$. (Or, we should say $(1, 1)$ divided by an interval $i$, is not a proper inverse of $i$ at the first place. See next paragraph for more details.)

That reminds me of the notion of *GROUP* in algebra. In the group theory, there are some important properties:
1. The group operation $\circ$ is closed. $a\circ b = c \in G$.
2. The group operation is associative, $a \circ (b \circ c) = (a \circ b) \circ c$.
3. There exists an /neutral/ element (or identity element), $1 \in G$, such that $a\circ 1 = 1 \circ a = a$ for all $a\in G$.
4. $\forall a \in G$, there exists an element $a^{-1} \in G$, called the /inverse/ of $a$, such that $a \circ a^{-1} = a^{-1} \circ a = 1$.
5. A group $G$ is abelian (or commutative) if, furthermore, $a \circ b = b \circ a$ for all $a,b \in G$.

If we define that an interval is valid only when the lower bound is not bigger than its upper bound, then it is not possible for us to find a inverse of this interval for the operation multiplication. For example, let $i = (3, 4)$. Obviously the identity element in interval arithmetic is $(1, 1)$. Then for operation multiplication, the inverse of $i$ should be $(1/3, 1/4)$. However, it is not a valid interval at all.

Thus the interval arithmetic system doesn't form a suitable group.

However, if we can define that intervals like $(1/3, 1/4)$ to be "imaginary" interval, then we can actually find the "real equivalent" formula and thus get identical results.

~par2~ generates the correct answer because it is closer to the formula of parallel resistors in a pure physical sense:
$$
\frac{1}{R_p} = \frac{1}{R_0} + \frac{1}{R_1} + \cdot + \frac{1}{R_n}
$$

And both ~par1~, ~par2~ can be considered "derived" from this formula. ~par2~, luckily, didn't touch the nasty situation of the interval multiplication arithmetic operation not being a group. But ~par1~ is not so luckily, and therefore always gives the wrong answer.
** 2.15
Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated. Thus, she says, ~par2~ is a "better" program for parallel resistances that ~par1~. Is she right? Why?

Basically, no. Because the reason for the wrong answer of Alyssa's system is more fundamental than just small errors accumulating, but in theory level.
For this question, see the prolonged discussion in exercise 2.14.
** 2.16
Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)

It is not about how we should re-define the behavior of the interval system, but rather we should re-define the meaning of "equivalent formulas". Some claim of equivalent ones in algebra settings are no longer true in interval arithmetic.

So, it is generally not possible if we enforce validity on any interval. Because the intervals and the multiplication operation together doesn't form a closed group in algebraically meaning. 

However, if we allow "imaginary intervals", it might be possible (not sure). I will not dive too deep into it now. But it sounds like something interesting to investigate so I will leave a TODO here.
#+begin_src scheme
;; TODO imaginary intervals
#+end_src

For more reasoning of this question, see the prolonged discussion in exercise 2.14.
** 2.17
Define a procedure ~last-pair~ that returns the list that contains only the last element of a given (nonempty) list:
#+begin_src scheme
(last-pair (list 23 72 149 34))
(34)
#+end_src

#+begin_src scheme
  (define (last-pair items)
    (if (null? (cdr items))
        (car items)
        (last-pair (cdr items))))
#+end_src
** 2.18
Define a procedure ~reverse~ that takes a list as argument and returns a list of the same elements in reverse order:
#+begin_src scheme
(reverse (list 1 4 9 16 25))
;; (25 16 9 4 1)
#+end_src

#+begin_src scheme
  ;; question: is recursive process possible here?
  ;; recursive is in natural building from outside into inside.
  ;; but here we need to build from inside out.
  ;; we can access the last element with last-pair easily
  ;; but I didn't find a very convenient way to peal the last element
  ;; from the original list so that next call of last-pair will return
  ;; a different value from a level above.
  (define (reverse items)
    (if (null? items)
        items
        ())) ;; I don't think it is possible here to do it with a recursive process
  ;; but how can I prove it mathematically?

  (define (reverse items)
    (define (reverse n res)
      (if (= n (length items)) ;; when it ends
          res
          (reverse (+ n 1)
                   (cons (list-ref items n) res))))
    (reverse 0 '()))
#+end_src
** 2.19
Consider the change-counting program of section 1.2.2. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure ~first-denomination~ and partly into the procedure ~count-change~ (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.

We want to rewrite the procedure ~cc~ so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:
#+begin_src scheme
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+end_src

We could then call ~cc~ as follows:
#+begin_src scheme
(cc 100 us-coins)
;; 292
#+end_src
To do this will require changing the program ~cc~ somewhat. It will still have the same form, but it will access its second argument differently, as follows:

#+begin_src scheme
  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else (+ (cc amount
                       (except-first-denomination coin-values))
                   (cc (- amount
                          (first-denomination coin-values))
                       coin-values)))))
#+end_src

Define the procedures ~no-more?~, ~except-first-denomination~, and ~first-denomination~ in terms of primitive operations on list structures. Does the order of the list ~coin-value~ affect the answer produced by ~cc~? Why and why not.

#+begin_src scheme
  (define (no-more? coin-values)
    (null? coin-values))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))
#+end_src

The order of the coin list will not affect the answer. Because it generates an recursive tree and each sub-tree are independent of the order they are generated.
** 2.20
The procedures ~+~, ~*~, and ~list~ take arbitrary numbers of arguments. One way to define such procedures is to use ~define~ with /dotted-tail-notation/. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedures is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter's value will be a list of any remaining arguments. For instance, given the definition:
#+begin_src scheme
(define (f x y . z) <body>)
#+end_src
the procedure ~f~ can be called with two or more arguments. If we evaluate:
#+begin_src scheme
(f 1 2 3 4 5 6)
#+end_src
then in the body of ~f~, ~x~ will be 1, ~y~ will be 2, and ~z~ will be the list ~(3 4 5 6)~.
Given the definition
#+begin_src scheme
(define (g . w) <body>)
#+end_src
the procedure ~g~ can be called with zero or more arguments. If we evaluate
#+begin_src scheme
(g 1 2 3 4 5 6)
#+end_src
then in the body of ~g~, ~w~ will be the list ~(1 2 3 4 5 6)~.

Use this notation to write a procedure ~same-parity~ that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,
#+begin_src scheme
(same-parity 1 2 3 4 5 6 7) ;; (1 3 5 7)
(same-parity 2 3 4 5 6 7)   ;; (2 4 6)
#+end_src

#+begin_src scheme
  (define (same-parity x . z)
    (filter-with (cons x z)
                 (if (even? x)
                     even?
                     odd?)))

  (define (even? x) (= (remainder x 2) 0))
  (define (odd? x) (not (even? x)))

  (define (filter-with lst test?)
    (cond ((null? lst) lst)
          ((test? (car lst))
           (cons (car lst)
                 (filter-with (cdr lst) test?))) ;; valid
          (else (filter-with (cdr lst) test?)))) ;; not valid, ignore and continue
#+end_src

I used the ~filter-with~ here to abstract the operation of filtering a list with some predicate.
** 2.21
The procedure ~square-list~ takes a list of numbers as argument and returns a list of the square of those numbers.
#+begin_src scheme
(square-list (list 1 2 3 4)) ;; 1 4 9 16
#+end_src

Here are two different definitions of ~square-list~. Complete both of them.
#+begin_src scheme
  (define (square-list items)
    (if (null? items)
        '()
        (cons (square (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map square items))
#+end_src
** 2.22
Louis Reasoner tries to rewrite the first ~square-list~ procedure of exercise 2.21 so that it evolves an iterative process:
#+begin_src scheme
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons (square (car things))
                      (answer)))))
    (iter items '()))
#+end_src

Unfortunately, defining ~square-list~ this way produces the answer list in the reverse order of the one desired. Why?

Because for an iterative process, it is always building up to the answer, which is wrapping the previous answer into something else. The following is the process the answer is built:
#+begin_src scheme
'()
(1 '())
(4 (1 '()))
(9 (4 (1 '())))
#+end_src

Louis then tries to fix his bug by interchanging the arguments to ~cons~:
#+begin_src scheme
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons answer
                      (square (car things))))))
    (iter items '()))
#+end_src

This doesn't work either. Explain.

It is essentially still building the answer from inside to outside, which is not a correct form of list.
#+begin_src scheme
'()
('() 1)
(('() 1) 4)
((('() 1) 4) 9)
#+end_src

Fun fact: this exercise is very similar to my comment on the lecture 3A post, which questioned how to implement the map with an iterative process, without mutable variables. I came up with something that looks like /iterative/ in the ~map~ procedure, but the ~map~ there resorts to another procedure ~put-in~, which puts an element in side a list. And ~put-in~ is still, in nature, /recursive/.

We cannot find a way to do similar stuff in an iterative way without mutable state or doing extra processing (do another iterative pass to the answer) because iterative process is "building up" the solution, while recursive is maintaining the structure using "backtracking". To do it iteratively, we either need to: 1. modify the actual value, or structure of the answer from previous iteration; 2. add another iterative pass to generate the desired answer.

How doing another iterative pass can help us solve this tho? We noticed that after the second Louis code, now the answer has a reverse inside-ouside relation among all elements. We can start ~car~-ing down (instead of ~cdr~-ing down because now the actual items are at the tails) the answer and build a ~answer2~ from inside out, which will be the desired structure.
** 2.23
The procedure ~for-each~ is similar to ~map~. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, ~for-each~ just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all--~for-each~ is used with procedures that perform an action, such as printing. For example:
#+begin_src scheme
  (for-each (lambda (x) (newline) (display x))
            (list 53 24 55))
  ;; 53
  ;; 24
  ;; 55
#+end_src
The value returned by the call to ~for-each~ (not illustrated above) can be something arbitrary, such as true. Give an implementation to ~for-each~.


#+begin_src scheme
  (define (for-each action items)
    (cond ((null? items) "done")
          (else (action (car items))
                (for-each action (cdr items)))))
#+end_src
** 2.24
Suppose we evaluate the expression ~(list 1 (list 2 (list 3 4)))~. Give the result printed by the interpreter, the corresponding box-and-pointer structures, and the interpretation of this as a tree.

Interpreter output: ~(1 (2 (3 4)))~.

Tree:
#+begin_src ditaa :file images/2.24tree.png
          root
         /    \
        1   (2 (3 4))
            /       \
           2       (3 4)
                   /   \
                  3     4
#+end_src

** 2.25
** 2.26
** 2.27
** 2.28
** 2.29
