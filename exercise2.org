* Chapter 2 Exercises
** 2.1
Define a better version of ~make-rat~ that handles both positive and negative arguments. ~Make-rat~ should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.
#+begin_src scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (make-rat n d)
    (cond ((and (> n 0) (> d 0)) (make-rat-with-sign 1 n d (gcd n d)))
          ((and (< n 0) (< d 0)) (make-rat-with-sign 1 (abs n) (abs d) (abs (gcd n d))))
          ((and (< n 0) (> d 0)) (make-rat-with-sign -1 (abs n) d (abs (gcd n d))))
          (else (make-rat-with-sign -1 n (abs d) (abs (gcd n d))))))

  (define (make-rat-with-sign sign n d g)
    "We assume that n, d, g are all positive."
    (if (= sign 1)
        (cons (/ n g) (/ d g))
        (cons (/ (- n) g) (/ d g))))
#+end_src
** 2.2
Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~ that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the $x$ coordinate and the $y$ coordinate. Accordingly, specify a constructor ~make-point~ and selectors ~x-point~ and ~y-point~ that define this representation. Finally, using your selectors and constructors, define a procedure ~midpoint-segment~ that takes a line segment as arguments and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you'll need a way to print points:
#+begin_src scheme
  (define )
#+end_src
** 2.3
