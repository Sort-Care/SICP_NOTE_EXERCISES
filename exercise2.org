#+BIND: geiser-scheme-implementation mit
#+STARTUP: nolatexpreview
* Chapter 2 Exercises
** 2.1
Define a better version of ~make-rat~ that handles both positive and negative arguments. ~Make-rat~ should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.
#+begin_src scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (make-rat n d)
    (cond ((and (> n 0) (> d 0)) (make-rat-with-sign 1 n d (gcd n d)))
          ((and (< n 0) (< d 0)) (make-rat-with-sign 1 (abs n) (abs d) (abs (gcd n d))))
          ((and (< n 0) (> d 0)) (make-rat-with-sign -1 (abs n) d (abs (gcd n d))))
          (else (make-rat-with-sign -1 n (abs d) (abs (gcd n d))))))

  (define (make-rat-with-sign sign n d g)
    "We assume that n, d, g are all positive."
    (if (= sign 1)
        (cons (/ n g) (/ d g))
        (cons (/ (- n) g) (/ d g))))
#+end_src
** 2.2
Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~ that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the $x$ coordinate and the $y$ coordinate. Accordingly, specify a constructor ~make-point~ and selectors ~x-point~ and ~y-point~ that define this representation. Finally, using your selectors and constructors, define a procedure ~midpoint-segment~ that takes a line segment as arguments and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you'll need a way to print points:
#+begin_src scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display (","))
    (display (y-point p))
    (display ")"))
#+end_src

#+begin_src scheme
  (define (midpoint-segment s)
    (let ((a (start-segment s))
          (b (end-segment s)))
      (make-point (/ (+ (x-point a)
                        (x-point b))
                     2.0)
                  (/ (+ (y-point a)
                        (y-point b))
                     2.0))))

  ;;--------- SEGMENT
  (define (make-segment p1 p2)
    (cons p1 p2))

  (define (start-segment s)
    (car s))

  (define (end-segment s)
    (cdr s))

  ;;--------- POINTS
  (define (make-point x y)
    (cons x y))

  (define (x-point p)
    (car p))

  (define (y-point p)
    (cdr p))
#+end_src
** 2.3
Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2). In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

#+begin_src scheme
  ;; ----------- PERIMETER and AREA of RECTANGLE
  (define (rect-perimeter rect)
    (+ (* (a-rect rect) 2)
       (* (b-rect rect) 2)))

  (define (rect-area rect)
    (* (a-rect rect) (b-rect rect)))

  ;; ----------- RECTANGLE REPRESENTATION 1
  ;; constructor
  ;; selector
  (define (make-rect seg1 seg2)
    (cons seg1 seg2))

  (define (a-rect rect)
    "Returns the length of one edge of rectangle."
    (seg-length (car rect)))

  (define (b-rect rect)
    "Returns the length of an adjacent edge of what a-rect returns."
    (seg-length (cdr rect)))


  ;; -----------
  (define (seg-length seg)
    (let ((a (start-segment seg))
          (b (end-segment seg)))
      (sqrt (+ (square (- (x-point a) (x-point b)))
                (square (- (y-point a) (y-point b)))))))
#+end_src

Then, try a different representation:
#+begin_src scheme
  (define (make-rect seg1 seg2)
    "Putting properties along with the segments."
    (cons (cons seg1 seg2)
          (cons (seg-length seg1) (seg-length seg2))))

  ;; because the calculation was done in the constructor,
  ;; we can make fetching them in following procedures faster
  ;; suitable for a application where the following are called
  ;; frequently.
  (define (a-rect rect)
    (car (cdr rect)))

  (define (b-rect rect)
    (cdr (cdr rect)))
#+end_src

** 2.4
Here is an alternative procedural representation of pairs. For this representation, verify that ~(car (cons x y))~ yields ~x~ for any objects ~x~ and ~y~.
#+begin_src scheme
  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))
#+end_src

What is the corresponding definition of ~cdr~? (Hint: To verify that this works make use of the substitution model of section 1.1.5)

#+begin_src scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+end_src

Then running ~(car (cons x y))~:
#+begin_src scheme
(car (cons x y))
(car (lambda (m) (m x y)))
((lambda (m) (m x y)) (lambda (p q) p))
((lambda (p q) p) x y)
x
#+end_src

My question: What will happen if we nest some pairs? Then try to select some inner elements.
#+begin_src scheme
  (define A (cons x y))
  (define B (cons A z))
  ;; then run
  (car (car B))

  ;;
  (car (car (cons A z)))
  (car (car (cons (cons x y) z)))
  (car (car (cons (lambda (m) (m x y)) z)))
  (car (car (lambda (m) (m (lambda (m) (m x y)) z))))
  (car ((lambda (m) (m (lambda (m) (m x y)) z)) (lambda (p q) p)))
  (car ((lambda (p q) p) (lambda (m) (m x y)) z))
  (car (lambda (m) (m x y)))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x
#+end_src
** 2.5
Show that we can represent pairs of non-negative integers using only numbers and arithmetic operations if we represent the pair $a$ and $b$ as the integer that is the product $2^a3^b$. Give the corresponding definitions of the procedures ~cons~, ~car~ and ~cdr~.

#+begin_src scheme
  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b
                   (fast-expt b (- n 1))))))

  (define (even? x)
    (= (remainder x 2) 0))

  (define (my-cons x y)
    (* (fast-expt 2 x)
       (fast-expt 3 y)))

  ;; how to get the x and y here easily?
  ;; The apparent solution is to utilize an iterative approach and divide the number.
  ;; But the running time of that approach is linear.
  ;; Is there an constant time solution?
  (define (my-car z)
    (how-many z 2))

  (define (my-cdr z)
    (how-many z 3))

  (define (how-many num div)
    (define (try-divide n res)
      (if (= (remainder n div) 0) ;; still can be divided by the div
          (try-divide (/ n div) (+ res 1)) ;; continue with new number and add 1 to the result
          res))
    (try-divide num 0))
#+end_src
** 2.6
In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as non-negative integers are concerned) by implementing 0 and the operation of adding 1 as:

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src
This representation is known as /Church numerals/, after its inventor, Alonzo Church, the logician who invented the $\lambda$ calculus.

Define ~one~ and ~two~ directly (not in terms of ~zero~ and ~add-1~). (Hint: Use substitution to evaluate ~(add-1 zero)~). Given a direct definition of the addition procedure ~+~ (not in terms of repeated application of ~add-1~).

First, let's try evaluate ~(add-1 zero)~:
#+begin_src scheme
  (add-1 zero)
  (add-1 (lambda (f)
           (lambda (x) x)))

  (lambda (f)
    (lambda (x)
      (f (((lambda (f)
             (lambda (x) x))
           f)
          x))))


  (lambda (f)
    (lambda (x)
      (f ((lambda (x) x)
          x))))

  (lambda (f)
    (lambda (x)
      (f x)))
  ;; ????
#+end_src

*** What is Church Numerals?
I really had difficulties in understanding this. So I resort to the wikipedia page, not for the exact answer, but for some insights.

And the following sentence at the very beginning of the article was very helpful:
#+begin_quote
Church numerals are the representations of natural numbers under Church encoding. The higher-order function that represents natural number $n$ is a function that maps any function $f$ to its n-fold composition. In simpler terms, the "value" of the numeral is equivalent to the number of times the function encapsulates its argument.

All Church numerals are functions that take two parameters.
#+end_quote

$$
f^{\circ n} = f \circ f \circ f \circ \cdots \circ f
$$

And to do the ~+~ procedure:

$$
plus(m, n) = m + n
$$

uses the identity
$$
f^{\circ (m+n)} (x) = f^{\circ m} ( f^{\circ n} (x))
$$

*** Then, Implement ~one~, ~two~, and ~+~ Procedure
#+begin_src scheme
  (define one
    (lambda (f) (lambda (x) (f x))))

  (define two
    (lambda (f) (lambda (x) (f (f x)))))

  (define +
    (lambda (f) (lambda (x) ((m f) ((n f) x)))))
#+end_src

To improve our understanding here, I decided to do more. Next I will try the ~mult~ procedure:

$$
f^{\circ (m\cdot n)}(x) = (f^{\circ n})^{\circ m} (x)
$$

which means apply function $f^{\cric n}$, $m$ times to $x$.

#+begin_src scheme
  (define (mul m n)
    (lambda (f) (lambda (x) ((m
                              (n f))
                             x))))
#+end_src

That is not so hard to understand. But next function: /predecessor/, is really hard to wrap your mind around it.
The predecessor function must return a function that applies its parameter $n-1$ times. This is achieved by building a container around $f$ and $x$, which is initialized in a way that omits the application of the function the first time.
#+begin_src scheme
;; TODO predecessor and minus procedure for Church Numerals
#+end_src
** 2.7
Alyssa's program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor
#+begin_src scheme
  (define (make-interval a b) (cons a b))
#+end_src
Define selectors ~upper-bound~ and ~lower-bound~ to complete the implementation.
#+begin_src scheme
  (define (lower-bound x) (car x))
  (define (upper-bound x) (cdr x))
#+end_src
** 2.8
Using reasoning analogous to Alyssa's, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called ~sub-interval~.

Because ~(sub-interval x y)~ is using some number within interval ~x~ and subtract it with some number within interval ~y~.
Thus the lower bound of the resulting interval is subtracting the upper bound of ~y~ from the lower bound of ~x~.
And the upper bound of the resulting interval is subtraction the lower bound of ~y~ from the upper bound of ~x~.
#+begin_src scheme
  (define (sub-interval x y)
    (make-interval (- (lower-bound x) (upper-bound y))
                   (- (upper-bound x) (lower-bound y))))
#+end_src
** 2.9
The /width/ of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the width of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the width of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.

Let's assume that $I_1$ and $I_2$ are two intervals we are going to apply arithmetic operations to. $I_3$ is the resulting interval.
Also, say $L_i$ and $U_i$ are the lower bound and upper bound of a interval $i$ respectively. $W_i$ is the width of interval $i$.

Then when the operation is sum:
$$
\begin{align*}
W_1 &= \frac{U_1 - L_1}{2} \\
W_2 &= \frac{U_2 - L_2}{2} \\
I_3 &= (L_1 + L_2, U_1 + U2) \\
W_3 &= \frac{(U_1 + U_2) - (L_1 + L_2)}{2} \\
&= \frac{(U_1 - L_1) + (U_2 - L_2)}{2} \\
&= W_1 + W_2
\end{align*}
$$

Similarly for difference:
$$
\begin{align*}
I_4 &= (L_1 - U_2, U_1 - L_2) \\
W_4 &= \frac{(U_1 - L_2) - (L_1 - U_2)}{2} \\
&= \frac{(U_1 - L_1) + (U_2 - L_2)}{2} \\
&= W_1 + W_2
\end{align*}
$$

And for multiplication, the obvious reason is that it is not a linear transformation of all bounds (~max~ and ~min~ are not linear transform operations). For example, if we have $(-1, 9)$ and $(3, 7)$, after multiplication, we get $(-7, 63)$. Number 3 did not even participated in forming the multiplication result.

Further more, even if there is no negative numbers involved, which means all transformations are linear:

$$
\begin{align*}
I_5 &= (L_1L_2, U_1U_2) \\
W_5 &= \frac{U_1U_2 - L_1L_2}{2}
\end{align*}
$$

We cannot represent $W_5$ in terms of $W_1$ and $W_2$ merely.
** 2.10
Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and comments that it is not clear what it means to divided by an interval that spans ~zero~. Modify Alyssa's code to check for this condition and to signal an error if it occurs.
#+begin_src scheme
  (define (div-interval x y)
    (if (<= (* (lower-bound y) (upper-bound y)) 0)
        (error "Divided by an interval that spans zero.")
        (mul-interval x
                      (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))
#+end_src
** 2.11
In passing, Ben also cryptically comments: "By testing the signs of the endpoints of the intervals, it is possible to break ~mul-interval~ into nine cases, only one of which requires more than two multiplications." Rewrite this procedure using Ben's suggestion.
#+begin_src scheme
  (define (mul-interval x y)
    (let ((l1 (lower-bound x))
          (u1 (upper-bound x))
          (l2 (lower-bound y))
          (u2 (upper-bound y)))
      (cond ((and (>= l1 0) (>= l2 0)) ;; both intervals are non-negative
             (make-interval (* l1 l2)
                            (* u1 u2)))
            ((and (< l1 0) (>= u1 0) (>= l2 0)) ;; x span zero, y above zero
             (make-interval (* l1 u2)
                            (* u1 u2)))
            ((and (< u1 0) (>= l2 0)) ;; x below zero, y above zero
             (make-interval (* l1 u2)
                            (* u1 l2)))
            ((and (>= l1 0) (< l2 0) (>= u2 0)) ;; x above zero, y span zero
             (make-interval (* l2 u1)
                            (* u1 u2)))
            ((and (< l1 0) (>= u1 0) (< l2 0) (>= u2 0)) ;; x span zero, y span zero
             (make-interval (min (* l1 u2) (* l2 u1))
                            (max (* l1 l2) (* u1 u2))))
            ((and (< u1 0) (< l2 0) (>= u2 0)) ;; x below zero, y span zero
             (make-interval (* l1 u2)
                            (* l1 l2)))
            ((and (>= l1 0) (< u2 0)) ;; x above zero, y below zero
             (make-interval (* l2 u1)
                            (* u2 l1)))
            ((and (< l1 0) (>= u1 0) (< u2 0)) ;; x span zero, y below zero
             (make-interval (* l2 u1)
                            (* l2 l1)))
            ((and (< u1 0) (< u2 0)) ;; x below zero, y below zero
             (make-interval (* l1 l2)
                            (* u1 u2))))))
#+end_src
** 2.12
Define a constructor ~make-center-percent~ that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector ~percent~ that produces the percentage tolerance for a given interval. The ~center~ selector is the same as the one shown above.
#+begin_src scheme
  (define (make-center-percent c p)
    (let ((t (* c p)))
      (make-interval (- c t)
                     (+ c t))))

  (define (center i)
    (/ (+ (lower-bound i) (upper-bound i)) 2))

  (define (percent i)
    (let ((c (center i)))
      (/ (- c (lower-bound i))
         c)))
#+end_src
** 2.13
Show that under the assumption of small percentage tolerance there is a simple formula for the approximate percentage tolerance of the product of two interval in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.

Let $c_i$, $p_i$, $l_i$, $u_i$ be the center, percentage, lower bound, upper bound of interval $i$. Say $I_3$ is the result of multiplying $I_1$ and $I_2$.

$$
\begin{align*}
l_1 &= c_1 - c_1 p_1 \\
l_2 &= c_2 - c_2 p_2 \\
l_3 &= c_1 c_2 (1 - p_1) (1 - p_2) \\
u_3 &= c_1 c_2 (1 + p_1) (1 + p_2) \\
c_3 &= \frac{c_1 c_2 ((1 - p_1) (1 - p_2) + (1 + p_1) (1 + p_2))}{2} \\
p_3 &= \frac{c_3 - l_3}{c_3} \\
    &= \frac{ \frac{c_1 c_2 ( (1 + p_1) (1 + p_2) - (1 - p_1) (1 - p_2))}{2} }{c_3} \\
    &= \frac{(1 + p_1) (1 + p_2) - (1 - p_1) (1 - p_2)}{(1 + p_1) (1 + p_2) + (1 - p_1) (1 - p_2)} \\
    &= \frac{p_1 + p_2}{1 + p_1 p_2}
\end{align*}
$$
** 2.14
Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals $A$ and $B$, and use them in computing the expressions $A/A$ and $A/B$. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see exercise 2.12).

#+begin_src scheme
  (define (print-interval i)
    (newline)
    (display "Lower Bound: ")
    (display (lower-bound i))
    (newline)
    (display "Upper Bound: ")
    (display (upper-bound i))
    (newline)
    (display "Center: ")
    (display (center i))
    (newline)
    (display "Tolerance Percent: ")
    (display (percent i)))
#+end_src

Ran it with:

#+begin_src scheme
  (define a (make-center-percent 50 0.0001))
  (define b (make-center-percent 63 0.0001))

  (print-interval (par1 a b))

  (print-interval (par2 a b))
#+end_src

Seems like the ~par1~ is giving the wrong answer here. The center is relatively accurate, but the lower bound and upper bound are not. And that leads to the percentage of tolerance of the result is not correct. But why does this happen?
#+begin_src bash
=> (print-interval (par1 a b))

Lower Bound: 27.867744477764607
Upper Bound: 27.88447014170444
Center: 27.876107309734522
Tolerance Percent: 2.9999999200013147e-4
;Unspecified return value

=> (print-interval (par2 a b))

Lower Bound: 27.87331858407079
Upper Bound: 27.878893805309733
Center: 27.876106194690262
Tolerance Percent: 1.0000000000007373e-4
;Unspecified return value
#+end_src

I get the most insight for this problem, in contrast to what the text said, from using intervals with large width.

It turned out that ~par1~ and ~par2~ are not computing the same thing at all when $R_1$ and $R_2$ are intervals. To see why, let's see what the procedure is really doing by explicitly writing out the calculations.

Let $A = (L_1, U_1)$, $B = (L_2, U_2)$.

For ~par1~:
$$
\begin{align*}
(mul \; a \; b) &= (L_1 L_2, U_1 U_2) \\
(add \; a \; b) &= (L_1 + L_2, U_1 + U_2) \\
\text{then perform division} &\\
\frac{(mul \; a \; b)}{(add \; a \; b)} &= (\frac{L_1 L_2}{U_1 + U_2}, \frac{U_1 U_2}{L_1 + L_2} )
\end{align*}
$$

While for ~par2~:

$$
\begin{align*}
(div \; one \; a) &= (\frac{1}{U_1}, \frac{1}{L_1}) \\
(div \; one \; b) &= (\frac{1}{U_2}, \frac{1}{L_1}) \\
\text{then add them together} &\\
sum &= (\frac{U_1 + U_2}{U_1 U_2}, \frac{L_1 + L_2}{L_1 L_2}) \\
\text{finally, divide one by the sum} &\\
(div \; one \; sum) &= (\frac{L_1 L_2}{L_1 + L_2}, \frac{U_1 U_2}{U_1 + U_2})
\end{align*}
$$

The problem is, although the two formulas are equivalent in pure algebra sense, they are not under the interval arithmetic. It lacks the property of $\frac{A}{B} \cdot B = A$. In the current interval arithmetic system, $\frac{A}{B} \cdot B \neq A$ in most cases (any case that the lower bound and upper bound of $B$ are not the same). And that, is what caused the inconsistency between two ways of computing the parallel resistor value.

More generally, the problem is, $A \cdot \frac{1}{A} \neq (1, 1)$. To put it in words, the product of an interval and its inverse ($(1, 1)$ divided by the interval) is not $(1,1)$. (Or, we should say $(1, 1)$ divided by an interval $i$, is not a proper inverse of $i$ at the first place. See next paragraph for more details.)

That reminds me of the notion of *GROUP* in algebra. In the group theory, there are some important properties:
1. The group operation $\circ$ is closed. $a\circ b = c \in G$.
2. The group operation is associative, $a \circ (b \circ c) = (a \circ b) \circ c$.
3. There exists an /neutral/ element (or identity element), $1 \in G$, such that $a\circ 1 = 1 \circ a = a$ for all $a\in G$.
4. $\forall a \in G$, there exists an element $a^{-1} \in G$, called the /inverse/ of $a$, such that $a \circ a^{-1} = a^{-1} \circ a = 1$.
5. A group $G$ is abelian (or commutative) if, furthermore, $a \circ b = b \circ a$ for all $a,b \in G$.

If we define that an interval is valid only when the lower bound is not bigger than its upper bound, then it is not possible for us to find a inverse of this interval for the operation multiplication. For example, let $i = (3, 4)$. Obviously the identity element in interval arithmetic is $(1, 1)$. Then for operation multiplication, the inverse of $i$ should be $(1/3, 1/4)$. However, it is not a valid interval at all.

Thus the interval arithmetic system doesn't form a suitable group.

However, if we can define that intervals like $(1/3, 1/4)$ to be "imaginary" interval, then we can actually find the "real equivalent" formula and thus get identical results.

~par2~ generates the correct answer because it is closer to the formula of parallel resistors in a pure physical sense:
$$
\frac{1}{R_p} = \frac{1}{R_0} + \frac{1}{R_1} + \cdot + \frac{1}{R_n}
$$

And both ~par1~, ~par2~ can be considered "derived" from this formula. ~par2~, luckily, didn't touch the nasty situation of the interval multiplication arithmetic operation not being a group. But ~par1~ is not so luckily, and therefore always gives the wrong answer.
** 2.15
Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa's system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated. Thus, she says, ~par2~ is a "better" program for parallel resistances that ~par1~. Is she right? Why?

Basically, no. Because the reason for the wrong answer of Alyssa's system is more fundamental than just small errors accumulating, but in theory level.
For this question, see the prolonged discussion in exercise 2.14.
** 2.16
Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)

It is not about how we should re-define the behavior of the interval system, but rather we should re-define the meaning of "equivalent formulas". Some claim of equivalent ones in algebra settings are no longer true in interval arithmetic.

So, it is generally not possible if we enforce validity on any interval. Because the intervals and the multiplication operation together doesn't form a closed group in algebraically meaning. 

However, if we allow "imaginary intervals", it might be possible (not sure). I will not dive too deep into it now. But it sounds like something interesting to investigate so I will leave a TODO here.
#+begin_src scheme
;; TODO imaginary intervals
#+end_src

For more reasoning of this question, see the prolonged discussion in exercise 2.14.
** 2.17
Define a procedure ~last-pair~ that returns the list that contains only the last element of a given (nonempty) list:
#+begin_src scheme
(last-pair (list 23 72 149 34))
(34)
#+end_src

#+begin_src scheme
  (define (last-pair items)
    (if (null? (cdr items))
        (car items)
        (last-pair (cdr items))))
#+end_src
** 2.18
Define a procedure ~reverse~ that takes a list as argument and returns a list of the same elements in reverse order:
#+begin_src scheme
(reverse (list 1 4 9 16 25))
;; (25 16 9 4 1)
#+end_src

#+begin_src scheme
    ;; question: is recursive process possible here?
    ;; recursive is in natural building from outside into inside.
    ;; but here we need to build from inside out.
    ;; we can access the last element with last-pair easily
    ;; but I didn't find a very convenient way to peal the last element
    ;; from the original list so that next call of last-pair will return
    ;; a different value from a level above.
    (define (reverse items)
      (if (null? items)
          items
          (tail-append (reverse (cdr items))
                       (car items)))) ;; I don't think it is possible here to do it with a recursive process
  ;; We actually can.
  ;; Wishful thinking again, assume we have a procedure tail-add
  (define (tail-append items x)
    (if (null? items)
        (cons x '())
        (cons (car items)
              (tail-append (cdr items) x))))

    (define (reverse items)
      (define (reverse n res)
        (if (= n (length items)) ;; when it ends
            res
            (reverse (+ n 1)
                     (cons (list-ref items n) res))))
      (reverse 0 '()))
#+end_src
** 2.19
Consider the change-counting program of section 1.2.2. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure ~first-denomination~ and partly into the procedure ~count-change~ (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.

We want to rewrite the procedure ~cc~ so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:
#+begin_src scheme
  (define us-coins (list 50 25 10 5 1))
  (define uk-coins (list 100 50 20 10 5 2 1 0.5))
#+end_src

We could then call ~cc~ as follows:
#+begin_src scheme
(cc 100 us-coins)
;; 292
#+end_src
To do this will require changing the program ~cc~ somewhat. It will still have the same form, but it will access its second argument differently, as follows:

#+begin_src scheme
  (define (cc amount coin-values)
    (cond ((= amount 0) 1)
          ((or (< amount 0) (no-more? coin-values)) 0)
          (else (+ (cc amount
                       (except-first-denomination coin-values))
                   (cc (- amount
                          (first-denomination coin-values))
                       coin-values)))))
#+end_src

Define the procedures ~no-more?~, ~except-first-denomination~, and ~first-denomination~ in terms of primitive operations on list structures. Does the order of the list ~coin-value~ affect the answer produced by ~cc~? Why and why not.

#+begin_src scheme
  (define (no-more? coin-values)
    (null? coin-values))

  (define (except-first-denomination coin-values)
    (cdr coin-values))

  (define (first-denomination coin-values)
    (car coin-values))
#+end_src

The order of the coin list will not affect the answer. Because it generates an recursive tree and each sub-tree are independent of the order they are generated.
** 2.20
The procedures ~+~, ~*~, and ~list~ take arbitrary numbers of arguments. One way to define such procedures is to use ~define~ with /dotted-tail-notation/. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedures is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter's value will be a list of any remaining arguments. For instance, given the definition:
#+begin_src scheme
(define (f x y . z) <body>)
#+end_src
the procedure ~f~ can be called with two or more arguments. If we evaluate:
#+begin_src scheme
(f 1 2 3 4 5 6)
#+end_src
then in the body of ~f~, ~x~ will be 1, ~y~ will be 2, and ~z~ will be the list ~(3 4 5 6)~.
Given the definition
#+begin_src scheme
(define (g . w) <body>)
#+end_src
the procedure ~g~ can be called with zero or more arguments. If we evaluate
#+begin_src scheme
(g 1 2 3 4 5 6)
#+end_src
then in the body of ~g~, ~w~ will be the list ~(1 2 3 4 5 6)~.

Use this notation to write a procedure ~same-parity~ that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,
#+begin_src scheme
(same-parity 1 2 3 4 5 6 7) ;; (1 3 5 7)
(same-parity 2 3 4 5 6 7)   ;; (2 4 6)
#+end_src

#+begin_src scheme
  (define (same-parity x . z)
    (filter-with (cons x z)
                 (if (even? x)
                     even?
                     odd?)))

  (define (even? x) (= (remainder x 2) 0))
  (define (odd? x) (not (even? x)))

  (define (filter-with lst test?)
    (cond ((null? lst) lst)
          ((test? (car lst))
           (cons (car lst)
                 (filter-with (cdr lst) test?))) ;; valid
          (else (filter-with (cdr lst) test?)))) ;; not valid, ignore and continue
#+end_src

I used the ~filter-with~ here to abstract the operation of filtering a list with some predicate.
** 2.21
The procedure ~square-list~ takes a list of numbers as argument and returns a list of the square of those numbers.
#+begin_src scheme
(square-list (list 1 2 3 4)) ;; 1 4 9 16
#+end_src

Here are two different definitions of ~square-list~. Complete both of them.
#+begin_src scheme
  (define (square-list items)
    (if (null? items)
        '()
        (cons (square (car items))
              (square-list (cdr items)))))

  (define (square-list items)
    (map square items))
#+end_src
** 2.22
Louis Reasoner tries to rewrite the first ~square-list~ procedure of exercise 2.21 so that it evolves an iterative process:
#+begin_src scheme
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons (square (car things))
                      (answer)))))
    (iter items '()))
#+end_src

Unfortunately, defining ~square-list~ this way produces the answer list in the reverse order of the one desired. Why?

Because for an iterative process, it is always building up to the answer, which is wrapping the previous answer into something else. The following is the process the answer is built:
#+begin_src scheme
'()
(1 '())
(4 (1 '()))
(9 (4 (1 '())))
#+end_src

Louis then tries to fix his bug by interchanging the arguments to ~cons~:
#+begin_src scheme
  (define (square-list items)
    (define (iter things answer)
      (if (null? things)
          answer
          (iter (cdr things)
                (cons answer
                      (square (car things))))))
    (iter items '()))
#+end_src

This doesn't work either. Explain.

It is essentially still building the answer from inside to outside, which is not a correct form of list.
#+begin_src scheme
'()
('() 1)
(('() 1) 4)
((('() 1) 4) 9)
#+end_src

Fun fact: this exercise is very similar to my comment on the lecture 3A post, which questioned how to implement the map with an iterative process, without mutable variables. I came up with something that looks like /iterative/ in the ~map~ procedure, but the ~map~ there resorts to another procedure ~put-in~, which puts an element in side a list. And ~put-in~ is still, in nature, /recursive/.

We cannot find a way to do similar stuff in an iterative way without mutable state or doing extra processing (do another iterative pass to the answer) because iterative process is "building up" the solution, while recursive is maintaining the structure using "backtracking". To do it iteratively, we either need to: 1. modify the actual value, or structure of the answer from previous iteration; 2. add another iterative pass to generate the desired answer.

How doing another iterative pass can help us solve this tho? We noticed that after the second Louis code, now the answer has a reverse inside-ouside relation among all elements. We can start ~car~-ing down (instead of ~cdr~-ing down because now the actual items are at the tails) the answer and build a ~answer2~ from inside out, which will be the desired structure.
** 2.23
The procedure ~for-each~ is similar to ~map~. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, ~for-each~ just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all--~for-each~ is used with procedures that perform an action, such as printing. For example:
#+begin_src scheme
  (for-each (lambda (x) (newline) (display x))
            (list 53 24 55))
  ;; 53
  ;; 24
  ;; 55
#+end_src
The value returned by the call to ~for-each~ (not illustrated above) can be something arbitrary, such as true. Give an implementation to ~for-each~.


#+begin_src scheme
  (define (for-each action items)
    (cond ((null? items) "done")
          (else (action (car items))
                (for-each action (cdr items)))))
#+end_src
** 2.24
Suppose we evaluate the expression ~(list 1 (list 2 (list 3 4)))~. Give the result printed by the interpreter, the corresponding box-and-pointer structures, and the interpretation of this as a tree.

Interpreter output: ~(1 (2 (3 4)))~.

Tree:
#+name: 2.24-list-tree
#+header: :results value file
#+header: :file images/2.24-tree.png 
#+header: :imagemagick yes :headers '("\\usepackage{tikz}") 
#+header: :fit yes :iminoptions -density 600 :imoutoptions -geometry 400
#+begin_src latex :file ./images/2.24-tree.png
  \begin{tikzpicture}
    \node {root}
      child {node {1}}
      child {node {(2 (3 4))}
        child {node {2}}
        child {node {(3 4)}
          child {node {3}}
          child {node {4}}
        }
      };
  \end{tikzpicture}
#+end_src

[[file:images/2.24-tree.png]]

** 2.25
Give combinations of ~car~ and ~cdr~ that will pick 7 from each of the following lists:
#+begin_src scheme
(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
#+end_src

#+begin_src scheme
  (define l1 (list 1 3 (list 5 7) 9))
  (car (cdr (car (cdr (cdr l1)))))

  (define l2 (list (list 7)))
  (car (car l2))

  (define l3 (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr l3))))))))))))
  ;; each (car (cdr)) pair gets the inner list
#+end_src
** 2.26
Suppose we define ~x~ and ~y~ to be two lists:
#+begin_src scheme
  (define x (list 1 2 3))
  (define y (list 4 5 6))
#+end_src
What is printed by the interpreter in response to evaluating each of the following expressions:
#+begin_src scheme
  (append x y)
  (cons x y)
  (list x y)
#+end_src

#+begin_src scheme
  (1 2 3 4 5 6)
  ((1 2 3) . (4 5 6)) ;; wrong
  ;; right answer
  ((1 2 3) 4 5 6)
  ((1 2 3) (4 5 6))
#+end_src
** 2.27
Modify your ~reverse~ procedure of exercise 2.18 to produce a ~deep-reverse~ procedure that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well. For example,
#+begin_src scheme
  (define x (list (list 1 2) (list 3 4)))

  x ;; ((1 2) (3 4))
  (reverse x)
  ;; ((3 4) (1 2))
  (deep-reverse x)
  ;; ((4 3) (2 1))
#+end_src

#+begin_src scheme
;; iterative process procedure
  (define (deep-reverse items)
    (define (deep-reverse-iter n res)
      (if (= n (length items))
          res
          (deep-reverse-iter (+ n 1)
                             (cons (deep-reverse (list-ref items n)) ;; recursive call
                                   res))))
    (if (list? items) ;; if it is a list
        (deep-reverse-iter 0 '()) ;; reverse it
        items)) ;; otherwise, just return it.

  ;; or recursive process procedure
  (define (deep-reverse items)
    (cond ((null? items) items)
          ((list? items) (tail-append (deep-reverse (cdr items))
                                      (deep-reverse (car items))))
          (else items))) ;; I don't think it is possible here to do it with a recursive process
  ;; We actually can.
  ;; Wishful thinking again, assume we have a procedure tail-add
  (define (tail-append items x)
    (if (null? items)
        (cons x '())
        (cons (car items)
              (tail-append (cdr items) x))))
#+end_src
** 2.28
Write a procedure ~fringe~ that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,
#+begin_src scheme
  (define x (list 1 2) (list 3 4))

  (fringe x) ;; (1 2 3 4)
  (fringe (list x x)) ;; (1 2 3 4 1 2 3 4)
#+end_src

#+begin_src scheme
  (define (fringe items)
    (cond ((null? items) '())
          ((not (pair? items)) (list items))
          (else (append (fringe (car items))
                        (fringe (cdr items))))))
#+end_src
** 2.29
A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using ~list~):
#+begin_src scheme
  (define (make-mobile left right)
    (list left right))
#+end_src

A branch is constructed from a ~length~ (which must be a number) together with a ~structure~, which may be either a number (representing a simple weight) or another mobile:
#+begin_src scheme
  (define (make-branch length structure)
    (list length structure))
#+end_src

- a. Write the corresponding selectors ~left-branch~ and ~right-branch~, which return the branches of a mobile, and ~branch-length~ and ~branch-structure~, which return the components of a branch.
#+begin_src scheme
  (define first (lambda (l) (list-ref l 0)))
  (define second (lambda (l) (list-ref l 1)))
  (define left-branch first)
  (define right-branch second)

  (define branch-length first)
  (define branch-structure second)
#+end_src
- b. Using your selectors, define a procedure ~total-weight~ that returns the total weight of a mobile.
#+begin_src scheme
  (define (total-weight mobile)
    (cond ((not (number? mobile))
           (let ((left-s (branch-structure (left-branch mobile)))
                 (right-s (branch-structure (right-branch mobile))))
             (+ (total-weight left-s)
                (total-weight right-s))))
          (else mobile))) ;; not list, return the number

  (define lfb (make-branch 0.3 10))
  (define rtb (make-branch 0.4 8))
  (define mob (make-mobile lfb rtb))
  (total-weight mob) ;; 18

  (define rtb2 (make-branch 0.4 mob))
  (define mob2 (make-mobile lfb rtb2))
  (total-weight mob2) ;; 10 + 18 = 28
#+end_src
- c. A mobile is said to be /balanced/ if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and it each of the sub-mobiles hanging off branches is balanced. Design a predicate that tests whether a binary mobile is balanced.
#+begin_src scheme
  (define (balanced? mobile)
    (cond ((number? mobile) true) ;; if it is a number
          (else (and (= (* (total-weight (branch-structure (left-branch mobile)))
                           (branch-length (left-branch mobile)))
                        (* (total-weight (branch-structure (right-branch mobile)))
                           (branch-length (right-branch mobile)))) ;; the top level is balanced
                     (balanced? (branch-structure (left-branch mobile)))
                     (balanced? (branch-structure (right-branch mobile))))))) ;; all sub-mobiles are balanced


  (define lfb (make-branch 3 4))
  (define rtb (make-branch 2 6))
  (define mob (make-mobile lfb rtb))
  (balanced? mob)

  (define lb2 (make-branch 0.2 3))
  (define rb2 (make-branch 0.2 3))
  (define submob (make-mobile lb2 rb2))
  (define rtb-new (make-branch 2 submob))
  (define mob2 (make-mobile lfb rtb-new))
  (balanced? mob2)
#+end_src
- d. Suppose we change the representation of mobiles so that the constructors are
#+begin_src scheme
  (define (make-mobile left right)
    (cons left right))
  (define (make-branch length structure)
    (cons length structure))
#+end_src
How much do you need to change your programs to convert to the new representation?

I was using the ~list?~ testing before, than I found that is actually dependent on the underlying implementation of a lower level so that was not quite right. So I changed it into ~(not (number? x))~ test because this only requires knowledge of the mobile data structure but not the actual implementation.

Back to the problem, if we change the ~list~ into ~cons~, the only thing we need to change is ~first~ and ~second~ procedures:
#+begin_src scheme
  (define first (lambda (x) (car x)))
  (define second (lambda (x) (cdr x)))
#+end_src
Nothing else need to be changed.
** 2.30
Define a procedure ~square-tree~ analogous to the ~square-list~ procedure of exercise 2.21. That is, ~square-tree~ should behave as follows:
#+begin_src scheme
    (square-tree
     (list 1
           (list 2 (list 3 4) 5)
           (list 6 7)))
    ;; (1 (4 (9 16) 25) (36 49))

  (define atree (list 1
                      (list 2 (list 3 4) 5)
                      (list 6 7)))
#+end_src
Define ~square-tree~ both directly (i.e. without using any higher-order procedures) and also by using ~map~ and recursion.

#+begin_src scheme
  (define (square-tree tree)
    (cond ((null? tree) '())
          ((not (pair? tree)) (square tree))
          (else (cons (square-tree (car tree))
                      (square-tree (cdr tree))))))

  (define (square-tree tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (square-tree sub-tree)
               (square sub-tree)))
         tree))
#+end_src
*** My note
Notice the different level of recursion here. ~map~ is a recursive process, but doesn't go further down along the tree, only the first level. That's why we see the ~lambda~ procedure we used when using ~map~ has its own recursive call as well. The ~map~ takes care of handling both children of a sub-tree. And the ~lambda~ takes care of any sub-tree handed to it with another call of ~square-tree~.

In other words, ~map~ ensures we and expanding to and processing both left and right child. ~lambda~ ensures we are diving down any sub-tree that exists.
** 2.31
Abstract your answer to exercise 2.30 to produce a procedure ~tree-map~ with the property that ~square-tree~ could be defined as
#+begin_src scheme
  (define (square-tree tree) (tree-map square tree))
#+end_src

#+begin_src scheme
  (define (tree-map proc tree)
    (map (lambda (sub-tree)
           (if (pair? sub-tree)
               (tree-map proc sub-tree)
               (proc sub-tree)))
         tree))
#+end_src
** 2.32
We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is ~(1 2 3)~, then the set of all subsets is ~(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))~. Complete the following definition of a procedure that generates the set of subsets of a set and give a clear explanation of how it works.

Here I closed the book and tried to think of how to implement this from scratch.

What I first thought of is using a binary number and start from 0000, all the way to 1111, using different digit to signal whether we take $i$ th element or not. But obviously that is not what we are talking about right now.

Another recursive solution, when we are considering $i$ the element, whether it is in the subset or not.
#+begin_src scheme
  (define (subsets items)
    (cond ((null? items) (list '()))
          ((pair? items) (let ((cdr-sub (subsets (cdr items))))
                           (append cdr-sub
                                   (append-to-every (list (car items)) cdr-sub))))))


  (define (append-to-every lst items)
    (map (lambda (l)
           (append lst
                   l))
         items))
#+end_src

This is very close the the answer in the book. The only difference is that I took our the ~map~ aside and put it into the procedure ~append-to-every~.
** 2.33
Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:
#+begin_src scheme
  (define (map p sequence)
    (accumulate (lambda (x y)
                  (cons (p x)
                        y))
                '()
                sequence))

  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))

  (define (length sequence)
    (accumulate (lambda (x y)
                  (1+ y))
                0
                sequence))
#+end_src
** 2.34
Evaluating a polynomial in $x$ at a given value of $x$ can be formulated as an accumulation. We evaluate the polynomial
$$
a_n x^n + a_{n-1} x^{n-1} + \cdots + a_1 x + a_0
$$
using a well-known algorithm called /Horner's rule/, which structures the computation as
$$
(\cdots (a_n x + a_{n-1})x + \cdots + a_1)x + a_0
$$
In other words, we start with $a_n$, multiply by $x$, add $a_{n-1}$, multiply by $x$, and so on, until we reach $a_0$. Fill in the following template to produce a procedure that evaluates a polynomial using Horner's rule. Assume that the coefficients of the polynomial are arranged in a sequence, from $a_0$ through $a_n$.
#+begin_src scheme
  (define (horner-eval x coefficient-sequence)
    (accumulate (lambda (this-coeff higher-terms)
                  (+ this-coeff
                     (* x higher-terms)))
                0
                coefficient-sequence))
#+end_src

*** Note
Horner's rule evaluates the polynomial using fewer additions and multiplications than does the straightforward method of first computing $a_n x^n$, then adding $a_{n-1} x^{n-1}$, and so on. In fact, it is possible to prove that any algorithm for evaluating arbitrary polynomials must use at least as many additions and multiplications as does Horner's rule, and thus *Horner's rule is an optimal algorithm for polynomial evaluation*.
** 2.35
Refine ~count-leaves~ from section 2.2.2 as an accumulation:
#+begin_src scheme
  (define (count-leaves t)
    (accumulate +
                0
                (map (lambda (x) ;; for each tree leaves, generate an 1.
                       1)
                     (enumerate-tree t))))
#+end_src
** 2.36
The procedure ~accumulate-n~ is similar to ~accumulate~ except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results.

For instance, if ~s~ is a sequence containing four sequences, ~((1 2 3) (4 5 6) (7 8 9) (10 11 12))~, then the value of ~(accumulate-n + 0 s)~ should be the sequence ~(22 26 30)~. Fill in the missing expressions in the following definition of ~accumulate-n~:

Also, I closed the book and try to come up with a complete solution.

#+begin_src scheme
  (define (accumulate-n op initial seqs)
    (if (null? (cdr seqs))
        '()
        (op-two-lists op
                      initial
                      (car seqs)
                      (accumulate-n op initial (cdr seqs)))))

  (define (op-two-lists op initial seq1 seq2)
    (cond ((and (null? seq1) (null? seq2)) '())
          ((null? seq1) (map (lambda (x) (op initial x)) seq2))
          ((null? seq2) (map (lambda (x) (op initial x)) seq1))
          (else (cons (op (car seq1) (car seq2))
                      (op-two-lists op initial (cdr seq1) (cdr seq2))))))
#+end_src
This works but I was still not capturing the style of processing because I still resort to a lot of condition branches.

#+begin_src scheme
  (define (accumulate-n op init seqs)
    (if (null? (car seqs))
        '()
        (cons (accumulate op init (map car seqs)) ;; all of the firs elements
              (accumulate-n op init (map cdr seqs))))) ;; all of the rest
#+end_src
** 2.37
Suppose we represent vectors $v=(v_i)$ as sequences of numbers, and matrices $m=(m_{ij})$ as sequences of vectors (the rows of the matrix). For example, the matrix
$$
\begin{bmatrix}
1 &2 &3 &4 \\
4 &5 &6 &6 \\
6 &7 &8 &9
\end{bmatrix}
$$
is represented as the sequence ~((1 2 3 4) (4 5 6 6) (6 7 8 9))~. With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:
- ~(dot-product v w)~: returns the sum $\sum_i v_i w_i$;
- ~(matrix-*-vector m v)~: returns the vector $t$, where $t_i = \sum_j m_{ij} v_j$
- ~(matrix-*-matrix m n)~: returns the matrix $p$, where $p_{ij} = \sum_k m_{ik} n_{kj}$;
- ~(transpose m)~: returns the matrix $n$, where $n_{ij} = m_{ji}$

We can define the dot product as
#+begin_src scheme
  (define (dot-product v w)
    (accumulate + 0 (map * v w)))
#+end_src

Fill in the missing expressions in the following procedures for computing the other matrix operations. (The procedure ~accumulate-n~ is defined in exercise 2.36.)
#+begin_src scheme
  (define (matrix-*-vector m v)
    (map (lambda (w)
           (dot-product v w))
         m))

  (define (transpose mat)
    (accumulate-n cons   ;; operation
                  '()    ;; initial value
                  mat))

  (define (matrix-*-matrix m n)
    (let ((cols (transpose n)))
      (map (lambda (v)
             (matrix-*-vector cols
                              v))
           m)))
#+end_src
** 2.38
The ~accumulate~ procedure is also known as ~fold-right~, because it combines the first element of the sequence with the result of combining all the elements to the right. There is also a ~fold-left~, which is similar to ~fold-right~, except that it combines elements working in the opposite direction:
#+begin_src scheme
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))
#+end_src

Give a property that ~op~ should satisfy to guarantee that ~fold-right~ and ~fold-left~ will produce the same values for any sequence.

Let's see what will be produced by both procedures. Say $\circ$ represents the operation, $e_i$ represents element $i$ in the sequence, $init$ represents the initial value:

For ~fold-right~:
$$
(e_1 \circ (e_2 \circ (e_3 \circ ( \cdots (e_n \circ init) \cdots ))))
$$

While for ~fold-left~:
$$
( \cdots (((init \circ e_1) \circ e_2) \circ e_3) \cdots \circ e_n)
$$

To make the two formula equivalent, ~op~ should be both associative and commutative.
** 2.39
Complete the following definitions of ~reverse~ (exercise 2.18) in terms of ~fold-right~ and ~fold-left~ from exercise 2.38:

#+begin_src scheme
  (define (reverse sequence)
    (fold-right (lambda (x y)
                  (append y
                          (list x)))
                '()
                sequence))

  (define (reverse sequence)
    (fold-left (lambda (x y)
                 (cons y x))
               '()
               sequence))
#+end_src
