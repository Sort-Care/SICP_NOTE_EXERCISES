#+STARTUP: nolatexpreview
* Chapter 2 Exercises
** 2.1
Define a better version of ~make-rat~ that handles both positive and negative arguments. ~Make-rat~ should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.
#+begin_src scheme
  (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

  (define (make-rat n d)
    (cond ((and (> n 0) (> d 0)) (make-rat-with-sign 1 n d (gcd n d)))
          ((and (< n 0) (< d 0)) (make-rat-with-sign 1 (abs n) (abs d) (abs (gcd n d))))
          ((and (< n 0) (> d 0)) (make-rat-with-sign -1 (abs n) d (abs (gcd n d))))
          (else (make-rat-with-sign -1 n (abs d) (abs (gcd n d))))))

  (define (make-rat-with-sign sign n d g)
    "We assume that n, d, g are all positive."
    (if (= sign 1)
        (cons (/ n g) (/ d g))
        (cons (/ (- n) g) (/ d g))))
#+end_src
** 2.2
Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor ~make-segment~ and selectors ~start-segment~ and ~end-segment~ that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the $x$ coordinate and the $y$ coordinate. Accordingly, specify a constructor ~make-point~ and selectors ~x-point~ and ~y-point~ that define this representation. Finally, using your selectors and constructors, define a procedure ~midpoint-segment~ that takes a line segment as arguments and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you'll need a way to print points:
#+begin_src scheme
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display (","))
    (display (y-point p))
    (display ")"))
#+end_src

#+begin_src scheme
  (define (midpoint-segment s)
    (let ((a (start-segment s))
          (b (end-segment s)))
      (make-point (/ (+ (x-point a)
                        (x-point b))
                     2.0)
                  (/ (+ (y-point a)
                        (y-point b))
                     2.0))))

  ;;--------- SEGMENT
  (define (make-segment p1 p2)
    (cons p1 p2))

  (define (start-segment s)
    (car s))

  (define (end-segment s)
    (cdr s))

  ;;--------- POINTS
  (define (make-point x y)
    (cons x y))

  (define (x-point p)
    (car p))

  (define (y-point p)
    (cdr p))
#+end_src
** 2.3
Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2). In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

#+begin_src scheme
  ;; ----------- PERIMETER and AREA of RECTANGLE
  (define (rect-perimeter rect)
    (+ (* (a-rect rect) 2)
       (* (b-rect rect) 2)))

  (define (rect-area rect)
    (* (a-rect rect) (b-rect rect)))

  ;; ----------- RECTANGLE REPRESENTATION 1
  ;; constructor
  ;; selector
  (define (make-rect seg1 seg2)
    (cons seg1 seg2))

  (define (a-rect rect)
    "Returns the length of one edge of rectangle."
    (seg-length (car rect)))

  (define (b-rect rect)
    "Returns the length of an adjacent edge of what a-rect returns."
    (seg-length (cdr rect)))


  ;; -----------
  (define (seg-length seg)
    (let ((a (start-segment seg))
          (b (end-segment seg)))
      (sqrt (+ (square (- (x-point a) (x-point b)))
                (square (- (y-point a) (y-point b)))))))
#+end_src

Then, try a different representation:
#+begin_src scheme
  (define (make-rect seg1 seg2)
    "Putting properties along with the segments."
    (cons (cons seg1 seg2)
          (cons (seg-length seg1) (seg-length seg2))))

  ;; because the calculation was done in the constructor,
  ;; we can make fetching them in following procedures faster
  ;; suitable for a application where the following are called
  ;; frequently.
  (define (a-rect rect)
    (car (cdr rect)))

  (define (b-rect rect)
    (cdr (cdr rect)))
#+end_src

** 2.4
Here is an alternative procedural representation of pairs. For this representation, verify that ~(car (cons x y))~ yields ~x~ for any objects ~x~ and ~y~.
#+begin_src scheme
  (define (cons x y)
    (lambda (m) (m x y)))

  (define (car z)
    (z (lambda (p q) p)))
#+end_src

What is the corresponding definition of ~cdr~? (Hint: To verify that this works make use of the substitution model of section 1.1.5)

#+begin_src scheme
  (define (cdr z)
    (z (lambda (p q) q)))
#+end_src

Then running ~(car (cons x y))~:
#+begin_src scheme
(car (cons x y))
(car (lambda (m) (m x y)))
((lambda (m) (m x y)) (lambda (p q) p))
((lambda (p q) p) x y)
x
#+end_src

My question: What will happen if we nest some pairs? Then try to select some inner elements.
#+begin_src scheme
  (define A (cons x y))
  (define B (cons A z))
  ;; then run
  (car (car B))

  ;;
  (car (car (cons A z)))
  (car (car (cons (cons x y) z)))
  (car (car (cons (lambda (m) (m x y)) z)))
  (car (car (lambda (m) (m (lambda (m) (m x y)) z))))
  (car ((lambda (m) (m (lambda (m) (m x y)) z)) (lambda (p q) p)))
  (car ((lambda (p q) p) (lambda (m) (m x y)) z))
  (car (lambda (m) (m x y)))
  ((lambda (m) (m x y)) (lambda (p q) p))
  ((lambda (p q) p) x y)
  x
#+end_src
** 2.5
Show that we can represent pairs of non-negative integers using only numbers and arithmetic operations if we represent the pair $a$ and $b$ as the integer that is the product $2^a3^b$. Give the corresponding definitions of the procedures ~cons~, ~car~ and ~cdr~.

#+begin_src scheme
  (define (fast-expt b n)
    (cond ((= n 0) 1)
          ((even? n) (square (fast-expt b (/ n 2))))
          (else (* b
                   (fast-expt b (- n 1))))))

  (define (even? x)
    (= (remainder x 2) 0))

  (define (my-cons x y)
    (* (fast-expt 2 x)
       (fast-expt 3 y)))

  ;; how to get the x and y here easily?
  ;; The apparent solution is to utilize an iterative approach and divide the number.
  ;; But the running time of that approach is linear.
  ;; Is there an constant time solution?
  (define (my-car z)
    (how-many z 2))

  (define (my-cdr z)
    (how-many z 3))

  (define (how-many num div)
    (define (try-divide n res)
      (if (= (remainder n div) 0) ;; still can be divided by the div
          (try-divide (/ n div) (+ res 1)) ;; continue with new number and add 1 to the result
          res))
    (try-divide num 0))
#+end_src
** 2.6
In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as non-negative integers are concerned) by implementing 0 and the operation of adding 1 as:

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src
This representation is known as /Church numerals/, after its inventor, Alonzo Church, the logician who invented the $\lambda$ calculus.

Define ~one~ and ~two~ directly (not in terms of ~zero~ and ~add-1~). (Hint: Use substitution to evaluate ~(add-1 zero)~). Given a direct definition of the addition procedure ~+~ (not in terms of repeated application of ~add-1~).

First, let's try evaluate ~(add-1 zero)~:
#+begin_src scheme
  (add-1 zero)
  (add-1 (lambda (f)
           (lambda (x) x)))

  (lambda (f)
    (lambda (x)
      (f (((lambda (f)
             (lambda (x) x))
           f)
          x))))


  (lambda (f)
    (lambda (x)
      (f ((lambda (x) x)
          x))))

  (lambda (f)
    (lambda (x)
      (f x)))
  ;; ????
#+end_src

*** What is Church Numerals?
I really had difficulties in understanding this. So I resort to the wikipedia page, not for the exact answer, but for some insights.

And the following sentence at the very beginning of the article was very helpful:
#+begin_quote
Church numerals are the representations of natural numbers under Church encoding. The higher-order function that represents natural number $n$ is a function that maps any function $f$ to its n-fold composition. In simpler terms, the "value" of the numeral is equivalent to the number of times the function encapsulates its argument.

All Church numerals are functions that take two parameters.
#+end_quote

$$
f^{\circ n} = f \circ f \circ f \circ \cdots \circ f
$$

And to do the ~+~ procedure:

$$
plus(m, n) = m + n
$$

uses the identity
$$
f^{\circ (m+n)} (x) = f^{\circ m} ( f^{\circ n} (x))
$$

*** Then, Implement ~one~, ~two~, and ~+~ Procedure
#+begin_src scheme
  (define one
    (lambda (f) (lambda (x) (f x))))

  (define two
    (lambda (f) (lambda (x) (f (f x)))))

  (define +
    (lambda (f) (lambda (x) ((m f) ((n f) x)))))
#+end_src

To improve our understanding here, I decided to do more. Next I will try the ~mult~ procedure:

$$
f^{\circ (m\cdot n)}(x) = (f^{\circ n})^{\circ m} (x)
$$

which means apply function $f^{\cric n}$, $m$ times to $x$.

#+begin_src scheme
  (define (mul m n)
    (lambda (f) (lambda (x) ((m
                              (n f))
                             x))))
#+end_src

That is not so hard to understand. But next function: /predecessor/, is really hard to wrap your mind around it.
The predecessor function must return a function that applies its parameter $n-1$ times. This is achieved by building a container around $f$ and $x$, which is initialized in a way that omits the application of the function the first time.
#+begin_src scheme
;; TODO predecessor and minus procedure for Church Numerals
#+end_src
